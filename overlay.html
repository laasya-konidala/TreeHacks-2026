<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%;
      height: 100%;
      background: transparent;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      overflow: hidden;
    }

    .panel {
      position: absolute;
      top: 16px;
      right: 16px;
      bottom: 16px;
      width: 340px;
      min-width: 260px;
      max-width: 600px;
      background: rgba(20, 20, 30, 0.85);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

    /* â”€â”€ Resize handle (left edge) â”€â”€ */
    .resize-handle {
      position: absolute;
      top: 0;
      left: -4px;
      width: 8px;
      height: 100%;
      cursor: ew-resize;
      z-index: 100;
      -webkit-app-region: no-drag;
    }
    .resize-handle::after {
      content: '';
      position: absolute;
      left: 3px;
      top: 50%;
      transform: translateY(-50%);
      width: 3px;
      height: 40px;
      border-radius: 2px;
      background: rgba(255, 255, 255, 0.15);
      transition: background 0.2s;
    }
    .resize-handle:hover::after,
    .resize-handle:active::after {
      background: rgba(255, 255, 255, 0.4);
    }

    /* â”€â”€ Header â”€â”€ */
    .header {
      padding: 16px 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      -webkit-app-region: drag;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .agent-icon {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
      transition: all 0.3s ease;
    }

    .agent-icon.conceptual { background: #8b5cf6; }
    .agent-icon.applied { background: #3b82f6; }
    .agent-icon.consolidation { background: #10b981; }
    .agent-icon.idle { background: rgba(255, 255, 255, 0.25); }

    .title {
      color: rgba(255, 255, 255, 0.9);
      font-size: 14px;
      font-weight: 600;
    }

    .subtitle {
      color: rgba(255, 255, 255, 0.4);
      font-size: 11px;
    }

    /* â”€â”€ Toggle button â”€â”€ */
    .toggle-btn {
      -webkit-app-region: no-drag;
      width: 40px;
      height: 24px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      position: relative;
      transition: background 0.3s;
      background: rgba(255, 255, 255, 0.15);
    }

    .toggle-btn.active {
      background: rgba(16, 185, 129, 0.6);
    }

    .toggle-btn::after {
      content: '';
      position: absolute;
      top: 3px;
      left: 3px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: white;
      transition: transform 0.3s;
    }

    .toggle-btn.active::after {
      transform: translateX(16px);
    }

    /* â”€â”€ Status bar â”€â”€ */
    .status-bar {
      padding: 8px 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }

    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.3);
      flex-shrink: 0;
      transition: background 0.3s;
    }

    .status-dot.ready { background: #fbbf24; }
    .status-dot.connecting { background: #f97316; animation: pulse 1s infinite; }
    .status-dot.active { background: #10b981; animation: pulse 2s infinite; }
    .status-dot.error { background: #ef4444; }
    .status-dot.disconnected { background: rgba(255, 255, 255, 0.3); }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    .status-text {
      color: rgba(255, 255, 255, 0.5);
      font-size: 11px;
      flex: 1;
    }

    .mic-indicator {
      font-size: 12px;
      opacity: 0.3;
      transition: opacity 0.3s;
    }

    .mic-indicator.listening {
      opacity: 1;
    }

    /* â”€â”€ Feed area â”€â”€ */
    .feed {
      flex: 1;
      overflow-y: auto;
      padding: 16px 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .feed::-webkit-scrollbar { width: 4px; }
    .feed::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 2px;
    }

    .feed-item {
      padding: 12px 14px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.06);
      animation: fadeIn 0.3s ease;
    }

    .feed-item .time {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.25);
      margin-bottom: 6px;
    }

    .feed-item .text {
      font-size: 13px;
      color: rgba(255, 255, 255, 0.8);
      line-height: 1.5;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .feed-item .speech-tag {
      font-size: 10px;
      color: rgba(139, 92, 246, 0.7);
      margin-bottom: 4px;
    }

    .feed-item.mode-CONCEPTUAL { border-left: 2px solid rgba(139, 92, 246, 0.5); }
    .feed-item.mode-APPLIED { border-left: 2px solid rgba(59, 130, 246, 0.5); }
    .feed-item.mode-CONSOLIDATION { border-left: 2px solid rgba(16, 185, 129, 0.5); }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: rgba(255, 255, 255, 0.25);
      font-size: 13px;
      text-align: center;
      padding: 40px;
      line-height: 1.6;
    }

    .empty-state .icon { font-size: 32px; margin-bottom: 12px; }

    /* â”€â”€ Visualization cards â”€â”€ */
    .viz-feed-card {
      margin-top: 4px;
      border-radius: 10px;
      overflow: visible;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.06);
      padding: 10px;
    }
    .viz-feed-card .viz-title {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.95);
      font-weight: 600;
      margin-bottom: 4px;
    }
    .viz-feed-card .viz-canvas {
      min-height: 140px;
      max-height: 500px;
      background: rgba(0, 0, 0, 0.15);
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 6px;
      overflow-x: hidden;
      overflow-y: auto;
    }
    .viz-feed-card .viz-canvas svg {
      width: 100% !important;
      height: auto !important;
      max-width: 100%;
      display: block;
    }
    .viz-feed-card .viz-narration {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
      line-height: 1.4;
    }
    .viz-feed-card .katex { font-size: 1.05em; }
    .viz-feed-card video {
      width: 100%;
      border-radius: 8px;
    }

    /* â”€â”€ Avatar dropdown â”€â”€ */
    .avatar-row {
      -webkit-app-region: no-drag;
      padding: 10px 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .avatar-label {
      color: rgba(255, 255, 255, 0.6);
      font-size: 12px;
      font-weight: 500;
    }
    .avatar-select {
      flex: 1;
      max-width: 140px;
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(255, 255, 255, 0.08);
      color: rgba(255, 255, 255, 0.9);
      font-size: 13px;
      cursor: pointer;
    }
    .avatar-select:focus {
      outline: none;
      border-color: rgba(16, 185, 129, 0.5);
    }

    /* â”€â”€ Call footer (voice bars + Slide to call + End conversation) â”€â”€ */
    .call-footer {
      padding: 14px 20px 16px;
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      display: flex;
      flex-direction: column;
      gap: 14px;
      -webkit-app-region: no-drag;
    }
    .voice-bars-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      height: 36px;
    }
    .voice-bar {
      width: 5px;
      height: 10px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.25);
    }
    .voice-bars-row.speaking .voice-bar {
      background: rgba(16, 185, 129, 0.9);
      animation: voiceBarSpeak 0.35s ease-in-out infinite alternate;
    }
    .voice-bars-row.speaking .voice-bar:nth-child(1) { animation-delay: 0s; }
    .voice-bars-row.speaking .voice-bar:nth-child(2) { animation-delay: 0.05s; }
    .voice-bars-row.speaking .voice-bar:nth-child(3) { animation-delay: 0.1s; }
    .voice-bars-row.speaking .voice-bar:nth-child(4) { animation-delay: 0.08s; }
    .voice-bars-row.speaking .voice-bar:nth-child(5) { animation-delay: 0.03s; }
    .voice-bars-row.speaking .voice-bar:nth-child(6) { animation-delay: 0.12s; }
    .voice-bars-row.speaking .voice-bar:nth-child(7) { animation-delay: 0.06s; }
    .voice-bars-row.speaking .voice-bar:nth-child(8) { animation-delay: 0.04s; }
    .voice-bars-row.speaking .voice-bar:nth-child(9) { animation-delay: 0.1s; }
    @keyframes voiceBarSpeak {
      from { height: 12px; }
      to { height: 28px; }
    }
    .call-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    .call-row.slide-row {
      justify-content: center;
      width: 100%;
      display: none;
    }
    .call-row.slide-row.visible {
      display: flex;
    }
    .slide-to-call-track {
      width: 100%;
      max-width: 300px;
      height: 56px;
      background: rgba(255, 255, 255, 0.12);
      border-radius: 28px;
      position: relative;
      cursor: pointer;
      overflow: hidden;
    }
    .slide-to-call-track .label {
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: rgba(255, 255, 255, 0.7);
      font-size: 16px;
      font-weight: 500;
      pointer-events: none;
      transition: opacity 0.2s;
    }
    .slide-to-call-track.triggered .label { opacity: 0; }
    .slide-to-call-thumb {
      position: absolute;
      left: 4px;
      top: 4px;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: white;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: grab;
      user-select: none;
      transition: transform 0.1s;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    .slide-to-call-thumb:active { cursor: grabbing; }
    .slide-to-call-thumb svg {
      width: 22px;
      height: 22px;
      color: #10b981;
    }
    .end-conversation-row {
      display: flex;
      justify-content: center;
    }
    .end-conversation-btn {
      padding: 8px 16px;
      border-radius: 8px;
      border: 1px solid rgba(239, 68, 68, 0.4);
      background: rgba(239, 68, 68, 0.2);
      color: #fca5a5;
      font-size: 13px;
      cursor: pointer;
    }
    .end-conversation-btn:hover { background: rgba(239, 68, 68, 0.35); }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</head>
<body>
  <div class="panel" id="panel">
    <div class="resize-handle" id="resizeHandle"></div>
    <div class="header">
      <div class="header-left">
        <div class="agent-icon idle" id="agentIcon"></div>
        <div>
          <div class="title" id="agentName">Curious Cat-alyst</div>
          <div class="subtitle" id="agentMode">Ready</div>
        </div>
      </div>
      <button class="toggle-btn" id="toggleBtn" title="Start/stop session"></button>
    </div>

    <div class="status-bar">
      <div class="status-dot" id="statusDot"></div>
      <span class="status-text" id="statusText">Initializing...</span>
      <span class="mic-indicator" id="micIndicator">ðŸŽ¤</span>
    </div>

    <div class="feed" id="feed">
      <div class="empty-state" id="emptyState">
        <div>Toggle the switch to start.<br>I'll watch your screen and help<br>you understand what you're learning.</div>
      </div>
    </div>

    <div class="call-footer">
      <div class="voice-bars-row" id="voiceBarsRow" aria-hidden="true">
        <div class="voice-bar"></div>
        <div class="voice-bar"></div>
        <div class="voice-bar"></div>
        <div class="voice-bar"></div>
        <div class="voice-bar"></div>
        <div class="voice-bar"></div>
        <div class="voice-bar"></div>
        <div class="voice-bar"></div>
        <div class="voice-bar"></div>
      </div>
      <div class="call-row slide-row" id="slideRow">
        <div class="slide-to-call-track" id="slideToCallTrack" title="Slide to unlock your question">
          <span class="label" id="slideToCallLabel">Slide to call</span>
          <div class="slide-to-call-thumb" id="slideToCallThumb">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 16.92v3a2 2 0 01-2.18 2 19.79 19.79 0 01-8.63-3.07 19.5 19.5 0 01-6-6 19.79 19.79 0 01-3.07-8.67A2 2 0 014.11 2h3a2 2 0 012 1.72 12.84 12.84 0 00.7 2.81 2 2 0 01-.45 2.11L8.09 9.91a16 16 0 006 6l1.27-1.27a2 2 0 012.11-.45 12.84 12.84 0 002.81.7A2 2 0 0122 16.92z"/></svg>
          </div>
        </div>
      </div>
      <div class="call-row end-conversation-row" id="endConversationRow" style="display: none;">
        <button class="end-conversation-btn" id="endConversationBtn">End conversation</button>
      </div>
    </div>
  </div>

  <script>
    const feed = document.getElementById('feed');
    const emptyState = document.getElementById('emptyState');
    const toggleBtn = document.getElementById('toggleBtn');
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const micIndicator = document.getElementById('micIndicator');
    const agentIcon = document.getElementById('agentIcon');
    const agentName = document.getElementById('agentName');
    const agentMode = document.getElementById('agentMode');

    let isActive = false;

    // â”€â”€ Speech Recognition (Web Speech API â€” runs locally) â”€â”€
    let recognition = null;

    function startSpeechRecognition() {
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        console.warn('[Speech] Web Speech API not available');
        return;
      }

      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = false;
      recognition.lang = 'en-US';

      recognition.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; i++) {
          if (event.results[i].isFinal) {
            const transcript = event.results[i][0].transcript.trim();
            if (transcript) {
              console.log('[Speech]', transcript);
              window.api.sendSpeechTranscript(transcript);
              if (pendingFirstVoiceResponse) {
                pendingFirstVoiceResponse = false;
                stopSpeechRecognition();
                startRealtimeVoice();
                if (endConversationRow) endConversationRow.style.display = 'flex';
              }
            }
          }
        }
      };

      recognition.onerror = (event) => {
        console.warn('[Speech] Error:', event.error);
        // Restart on non-fatal errors
        if (event.error === 'no-speech' || event.error === 'aborted') {
          if (isActive) {
            setTimeout(() => {
              try { recognition.start(); } catch (e) {}
            }, 500);
          }
        }
      };

      recognition.onend = () => {
        if (isActive && !realtimeSession) {
          try { recognition.start(); } catch (e) {}
        }
        micIndicator.classList.toggle('listening', isActive && !realtimeSession);
      };

      try {
        recognition.start();
        micIndicator.classList.add('listening');
        console.log('[Speech] Recognition started');
      } catch (e) {
        console.error('[Speech] Start error:', e);
      }
    }

    function stopSpeechRecognition() {
      if (recognition) {
        try { recognition.stop(); } catch (e) {}
        recognition = null;
      }
      micIndicator.classList.remove('listening');
    }

    // Avatar dropdown removed

    // â”€â”€ Panel resize logic â”€â”€
    (function() {
      var panel = document.getElementById('panel');
      var handle = document.getElementById('resizeHandle');
      var dragging = false;
      var startX, startWidth;

      handle.addEventListener('mousedown', function(e) {
        e.preventDefault();
        dragging = true;
        startX = e.clientX;
        startWidth = panel.offsetWidth;
        document.body.style.cursor = 'ew-resize';
        document.body.style.userSelect = 'none';
      });

      document.addEventListener('mousemove', function(e) {
        if (!dragging) return;
        // Dragging left edge: moving mouse left = wider, right = narrower
        var delta = startX - e.clientX;
        var newWidth = Math.min(600, Math.max(260, startWidth + delta));
        panel.style.width = newWidth + 'px';
      });

      document.addEventListener('mouseup', function() {
        if (!dragging) return;
        dragging = false;
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
        // Re-render any Plotly charts to fit new width
        panel.querySelectorAll('.viz-canvas .js-plotly-plot').forEach(function(el) {
          if (window.Plotly) Plotly.Plots.resize(el);
        });
      });
    })();

    // â”€â”€ IPC listeners â”€â”€
    // Speech recognition disabled â€” causes chunked_data_pipe spam in Electron
    window.api.onStartMic(() => { /* disabled */ });
    window.api.onStopMic(() => { /* disabled */ });

    // â”€â”€ Visualization rendering â”€â”€
    const BACKEND_ORIGIN = 'http://localhost:3000';

    // Make any SVG inside a container responsive â€” adds viewBox if missing, removes fixed dimensions
    function makeSvgResponsive(containerEl) {
      var svgs = containerEl.querySelectorAll('svg');
      svgs.forEach(function(svg) {
        var w = svg.getAttribute('width');
        var h = svg.getAttribute('height');
        if (w && h && !svg.getAttribute('viewBox')) {
          // Strip 'px' if present
          var nw = parseFloat(w) || 300;
          var nh = parseFloat(h) || 200;
          svg.setAttribute('viewBox', '0 0 ' + nw + ' ' + nh);
        }
        svg.removeAttribute('width');
        svg.removeAttribute('height');
        svg.style.width = '100%';
        svg.style.height = 'auto';
        svg.style.maxWidth = '100%';
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
      });
    }

    function renderVizInCard(tier, payload, canvasEl) {
      if (!canvasEl) return;

      // LaTeX
      if (tier === 'latex' || (tier === 'static' && (payload.format || 'latex') === 'latex')) {
        var content = payload.content || '';
        // Check if content looks like actual LaTeX (has backslash commands or math symbols)
        var looksLikeLatex = /[\\{}_^]/.test(content);
        if (looksLikeLatex && window.katex) {
          canvasEl.innerHTML = '';
          var wrap = document.createElement('div');
          wrap.style.overflowX = 'auto';
          wrap.style.textAlign = 'center';
          canvasEl.appendChild(wrap);
          try {
            katex.render(content, wrap, { throwOnError: false, displayMode: true });
          } catch (e) {
            wrap.innerHTML = '<p style="color:#d1d5db;font-size:13px;line-height:1.5;white-space:normal;word-wrap:break-word;">' + escapeHtml(content) + '</p>';
          }
        } else {
          // Plain text fallback â€” not actual LaTeX
          canvasEl.innerHTML = '<p style="color:#d1d5db;font-size:13px;line-height:1.5;padding:12px;white-space:normal;word-wrap:break-word;">' + escapeHtml(content || 'No content available.') + '</p>';
        }
        return;
      }

      // Mermaid (static with format=mermaid)
      if (tier === 'static' && payload.format === 'mermaid') {
        var content = payload.content || '';
        if (window.mermaid) {
          canvasEl.innerHTML = '<div class="mermaid">' + escapeHtml(content) + '</div>';
          mermaid.run({ nodes: [canvasEl.querySelector('.mermaid')] }).catch(function() {});
        } else {
          canvasEl.innerHTML = '<pre style="color:#9ca3af;">' + escapeHtml(content) + '</pre>';
        }
        return;
      }

      // D3 (direct rendering â€” D3 loaded in page head, no iframe needed)
      if (tier === 'd3' && payload.code) {
        canvasEl.innerHTML = '<p style="color:#9ca3af;font-size:11px;text-align:center;">Rendering D3...</p>';
        canvasEl.style.minHeight = '120px';
        canvasEl.style.background = 'rgba(0,0,0,0.15)';
        canvasEl.style.borderRadius = '8px';
        canvasEl.style.padding = '8px';
        canvasEl.style.overflow = 'hidden';

        console.log('[D3 render] d3 loaded:', !!window.d3, '| code length:', payload.code.length);

        if (!window.d3) {
          canvasEl.innerHTML = '<p style="color:#ef4444;font-size:12px;">D3 library not loaded â€” check network</p>';
          return;
        }

        try {
          canvasEl.innerHTML = '';
          var code = payload.code;

          // Sanitize common LLM code issues before attempting execution
          function sanitizeD3Code(src) {
            // Strip markdown fences if Claude wrapped the code
            src = src.replace(/^```[\w]*\n?/gm, '').replace(/```$/gm, '');
            // Replace smart/curly quotes with straight quotes
            src = src.replace(/[\u2018\u2019]/g, "'").replace(/[\u201C\u201D]/g, '"');
            // Replace arrow functions: (d) => expr  â†’  function(d) { return expr; }
            // Simple single-expression arrows only
            src = src.replace(/\(([^)]*)\)\s*=>\s*([^{;\n]+)/g, 'function($1) { return $2; }');
            src = src.replace(/([a-zA-Z_$]\w*)\s*=>\s*([^{;\n]+)/g, 'function($1) { return $2; }');
            return src;
          }

          code = sanitizeD3Code(code);

          var fn;
          var suffix = '\n;if(typeof draw==="function")draw(container);';
          try {
            fn = new Function('container', code + suffix);
          } catch (syntaxErr) {
            console.warn('[D3 render] SyntaxError (attempt 1):', syntaxErr.message);
            // Attempt 2: replace single quotes with double quotes
            var code2 = code.replace(/'/g, '"');
            try {
              fn = new Function('container', code2 + suffix);
              code = code2;
            } catch (syntaxErr2) {
              console.warn('[D3 render] SyntaxError (attempt 2):', syntaxErr2.message);
              // Attempt 3: replace single quotes with backticks (template literals)
              var code3 = code.replace(/'/g, '`');
              try {
                fn = new Function('container', code3 + suffix);
                code = code3;
              } catch (syntaxErr3) {
                console.warn('[D3 render] SyntaxError (attempt 3):', syntaxErr3.message);
                // Give up â€” show the error
                throw syntaxErr;
              }
            }
          }
          fn(canvasEl);
          // Make any generated SVGs responsive so they fit the sidebar
          makeSvgResponsive(canvasEl);
          console.log('[D3 render] Success â€” children:', canvasEl.children.length);
          if (canvasEl.children.length === 0 && !canvasEl.querySelector('svg')) {
            canvasEl.innerHTML = '<p style="color:#f59e0b;font-size:12px;">D3 code ran but produced no visible output</p>';
          }
        } catch (e) {
          console.error('[D3 render] Error:', e);
          canvasEl.innerHTML = '<p style="color:#ef4444;font-size:12px;">D3 error: ' + escapeHtml(e.message) + '</p>';
        }
        return;
      }

      // Plotly
      if ((tier === 'plotly' || tier === 'interactive') && payload.plotly_figure && window.Plotly) {
        canvasEl.innerHTML = '';
        var layout = Object.assign({}, payload.plotly_figure.layout || {});
        // Force layout to fit sidebar width
        layout.width = undefined;
        layout.autosize = true;
        layout.margin = layout.margin || { l: 40, r: 20, t: 30, b: 40 };
        layout.paper_bgcolor = 'rgba(0,0,0,0)';
        layout.plot_bgcolor = 'rgba(0,0,0,0.05)';
        layout.font = Object.assign({}, layout.font || {}, { color: 'rgba(255,255,255,0.8)', size: 11 });
        Plotly.newPlot(canvasEl, payload.plotly_figure.data || [], layout, { responsive: true, displayModeBar: false });
        return;
      }

      // Manim â€” poll for rendered video
      if (tier === 'manim') {
        var statusUrl = payload.status_url;
        var narrationText = payload.narration || 'Rendering animation...';

        if (statusUrl) {
          canvasEl.innerHTML = '<p style="color:#9ca3af;text-align:center;">ðŸŽ¬ ' + escapeHtml(narrationText) + '</p>' +
            '<p style="color:rgba(255,255,255,0.4);font-size:11px;text-align:center;">Rendering...</p>';
          var polls = 0, maxPolls = 80;
          var iv = setInterval(function() {
            polls++;
            fetch(BACKEND_ORIGIN + statusUrl).then(function(r) { return r.json(); }).then(function(data) {
              if (data.status === 'ready' && data.url) {
                clearInterval(iv);
                canvasEl.innerHTML = '<video src="' + BACKEND_ORIGIN + data.url + '" controls playsinline autoplay muted style="width:100%;border-radius:8px;"></video>';
              } else if (data.status === 'error') {
                clearInterval(iv);
                canvasEl.innerHTML = '<p style="color:#ef4444;text-align:center;font-size:12px;">' + escapeHtml(data.error || 'Render failed') + '</p>';
              }
            }).catch(function() {});
            if (polls >= maxPolls) {
              clearInterval(iv);
              canvasEl.innerHTML = '<p style="color:#9ca3af;text-align:center;">Render timed out.</p>';
            }
          }, 2000);
        } else {
          canvasEl.innerHTML = '<p style="color:#9ca3af;text-align:center;">ðŸŽ¬ ' + escapeHtml(narrationText) + '</p>';
        }
        return;
      }

      // Fallback
      canvasEl.innerHTML = '<p style="color:#6b7280;">' + escapeHtml(payload.title || 'Visualization') + '</p>';
    }

    // â”€â”€ Agent responses from backend (via WebSocket â†’ main â†’ IPC) â”€â”€
    window.api.onAgentResponse((msg) => {
      emptyState.style.display = 'none';

      // Debug: log everything we receive
      console.log('[overlay] agent-response received:', JSON.stringify({
        content_type: msg.content_type,
        tool_used: msg.tool_used,
        has_metadata: !!msg.metadata,
        tier: (msg.metadata || {}).tier,
        has_viz: !!((msg.metadata || {}).visualization),
        has_code: !!((msg.metadata || {}).visualization || {}).code,
        d3_loaded: !!window.d3,
      }));

      const meta = msg.metadata || {};
      const tier = meta.tier;
      const vizPayload = meta.visualization || meta.scene || {};
      const isViz = msg.content_type === 'visualization' || (msg.tool_used === 'visualization' && (tier || vizPayload.tier));

      if (isViz && (tier || vizPayload.tier)) {
        const actualTier = tier || vizPayload.tier;
        const cardId = 'viz-' + Date.now();
        const item = document.createElement('div');
        item.className = 'feed-item viz-feed-card';
        const now = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        item.innerHTML = '<div class="time">' + now + ' ðŸŽ¨ ' + actualTier + '</div>' +
          '<div class="viz-title">' + escapeHtml(vizPayload.title || 'Visualization') + '</div>' +
          '<div class="viz-canvas" id="' + cardId + '"></div>' +
          '<div class="viz-narration">' + escapeHtml((msg.content || vizPayload.narration || '').substring(0, 150)) + '</div>';
        feed.appendChild(item);
        feed.scrollTop = feed.scrollHeight;
        const canvas = document.getElementById(cardId);
        if (canvas) setTimeout(function() {
          renderVizInCard(actualTier, vizPayload, canvas);
          // Re-scroll after render so the full card (including narration) is visible
          setTimeout(function() { feed.scrollTop = feed.scrollHeight; }, 100);
          setTimeout(function() { feed.scrollTop = feed.scrollHeight; }, 500);
        }, 50);
        return;
      }

      // voice_call: show slide row with "Unlock your question", cat will say it on unlock (no feed item)
      if (msg.tool_used === 'voice_call' && (msg.content || '').trim()) {
        pendingVoiceQuestion = (msg.content || '').trim();
        const slideRowEl = document.getElementById('slideRow');
        if (slideRowEl) {
          slideRowEl.classList.add('visible');
          slideToCallLabel.textContent = 'Unlock your question';
          if (window.resetSlideThumb) window.resetSlideThumb();
        }
        return;
      }

      // Non-visualization agent response
      const agentLabel = { conceptual: 'Conceptual', applied: 'Applied', extension: 'Extension', visualizer: 'Visualizer' }[msg.agent_type] || msg.agent_type || 'Agent';
      const item = document.createElement('div');
      item.className = 'feed-item';
      const now = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      item.innerHTML = '<div class="time">' + now + ' ðŸ¤– ' + escapeHtml(agentLabel) + '</div>' +
        '<div class="text">' + escapeHtml(msg.content || '') + '</div>';
      feed.appendChild(item);
      feed.scrollTop = feed.scrollHeight;
    });

    window.api.onGeminiResponse((data) => {
      emptyState.style.display = 'none';

      // Detect mode from response and update the header indicator
      let mode = '';
      const text = data.text;
      if (text.includes('"CONCEPTUAL"') || text.includes("CONCEPTUAL")) mode = 'CONCEPTUAL';
      else if (text.includes('"APPLIED"') || text.includes("APPLIED")) mode = 'APPLIED';
      else if (text.includes('"CONSOLIDATION"') || text.includes("CONSOLIDATION")) mode = 'CONSOLIDATION';

      if (mode) updateAgentDisplay(mode);

      // Don't add VLM observations to the feed â€” they bury agent responses.
      // The mode indicator in the header is enough visual feedback.
      console.log('[VLM] mode:', mode, '| text length:', text.length);
    });

    window.api.onStatusUpdate((data) => {
      statusDot.className = `status-dot ${data.status}`;
      statusText.textContent = data.message;
    });

    // â”€â”€ Toggle â”€â”€
    toggleBtn.addEventListener('click', () => {
      isActive = !isActive;
      toggleBtn.classList.toggle('active', isActive);
      window.api.toggleSession();

      if (!isActive) {
        agentIcon.className = 'agent-icon idle';
        agentIcon.textContent = '';
        agentName.textContent = 'Curious Cat-alyst';
        agentMode.textContent = 'Ready';
      }
    });

    // â”€â”€ Agent display â”€â”€
    function updateAgentDisplay(mode) {
      const agents = {
        CONCEPTUAL: { name: 'Conceptual', color: 'conceptual' },
        APPLIED: { name: 'Applied', color: 'applied' },
        CONSOLIDATION: { name: 'Extension', color: 'consolidation' },
      };
      const agent = agents[mode];
      if (!agent) return;

      agentIcon.textContent = '';
      agentIcon.className = `agent-icon ${agent.color}`;
      agentName.textContent = agent.name + ' Mode';
      agentMode.textContent = 'Active';
    }

    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    // â”€â”€ Zoom & Realtime voice (call footer) â”€â”€
    const BACKEND_URL = 'http://localhost:3000';
    const slideToCallTrack = document.getElementById('slideToCallTrack');
    const slideToCallThumb = document.getElementById('slideToCallThumb');
    const slideToCallLabel = document.getElementById('slideToCallLabel');
    const voiceBarsRow = document.getElementById('voiceBarsRow');
    let pendingVoiceQuestion = null;
    let pendingFirstVoiceResponse = false;
    const endConversationRow = document.getElementById('endConversationRow');
    const endConversationBtn = document.getElementById('endConversationBtn');

    let realtimeSession = null;

    async function startRealtimeVoice() {
      if (realtimeSession) return;
      try {
        const r = await fetch(`${BACKEND_URL}/realtime/config`);
        const config = await r.json();
        if (config.error || !config.apiKey) {
          console.warn('[Realtime]', config.error || 'No API key');
          return;
        }
        const { RealtimeAgent, RealtimeSession: RSession } = await import('https://esm.sh/@openai/agents@0.4/realtime');
        const agent = new RealtimeAgent({ name: 'Cat', instructions: config.instructions || 'You are a helpful assistant.' });
        const session = new RSession(agent);
        await session.connect({ apiKey: config.apiKey });
        realtimeSession = session;
        if (voiceBarsRow) voiceBarsRow.classList.add('speaking');
        console.log('[Realtime] Voice agent listening');
      } catch (e) {
        console.warn('[Realtime] Failed to start:', e);
      }
    }

    function stopRealtimeVoice() {
      if (realtimeSession) {
        try {
          if (typeof realtimeSession.close === 'function') realtimeSession.close();
          else if (realtimeSession.transport && typeof realtimeSession.transport.close === 'function') realtimeSession.transport.close();
        } catch (e) {}
        realtimeSession = null;
        if (voiceBarsRow) voiceBarsRow.classList.remove('speaking');
        console.log('[Realtime] Voice agent stopped');
      }
    }

    async function launchZoomCall() {
      try {
        const r = await fetch(`${BACKEND_URL}/zoom/create-meeting`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: '{}' });
        const data = await r.json();
        if (data.error || !data.join_url) {
          statusText.textContent = data.error || 'Could not create meeting';
          return;
        }
        slideToCallLabel.textContent = 'In call';
        window.api.launchZoomMeeting(data.join_url);
        await startRealtimeVoice();
      } catch (e) {
        statusText.textContent = 'Backend not running. Start run.py first.';
      }
    }

    (function initSlideToCall() {
      let inCall = false;
      let dragging = false;
      let startX = 0;
      let currentX = 0;
      const thumb = slideToCallThumb;
      const track = slideToCallTrack;

      function getMaxSlide() {
        return track.offsetWidth - thumb.offsetWidth - 8;
      }

      function setThumbPosition(px) {
        const maxSlide = getMaxSlide();
        const x = Math.max(0, Math.min(px, maxSlide));
        currentX = x;
        thumb.style.transform = `translateX(${x}px)`;
        track.classList.toggle('triggered', x >= maxSlide * 0.85);
        return x;
      }

      function resetThumb() {
        currentX = 0;
        thumb.style.transform = 'translateX(0)';
        track.classList.remove('triggered');
      }
      window.resetSlideThumb = resetThumb;

      thumb.addEventListener('mousedown', (e) => {
        e.preventDefault();
        if (inCall) return;
        dragging = true;
        startX = e.clientX - currentX;
      });
      track.addEventListener('mousedown', (e) => {
        if (inCall || e.target === thumb) return;
        dragging = true;
        startX = e.clientX - currentX;
      });

      document.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        setThumbPosition(e.clientX - startX);
      });

      document.addEventListener('mouseup', () => {
        if (!dragging) return;
        dragging = false;
        const maxSlide = getMaxSlide();
        if (currentX >= maxSlide * 0.85) {
          if (pendingVoiceQuestion) {
            const toSpeak = pendingVoiceQuestion;
            pendingVoiceQuestion = null;
            resetThumb();
            const slideRowEl = document.getElementById('slideRow');
            if (slideRowEl) slideRowEl.classList.remove('visible');
            slideToCallLabel.textContent = 'Slide to call';
            if (voiceBarsRow) voiceBarsRow.classList.add('speaking');
            const u = new SpeechSynthesisUtterance(toSpeak);
            u.onend = () => {
              if (voiceBarsRow) voiceBarsRow.classList.remove('speaking');
              if (isActive && typeof startSpeechRecognition === 'function') {
                pendingFirstVoiceResponse = true;
                startSpeechRecognition();
              }
            };
            speechSynthesis.speak(u);
          } else {
            inCall = true;
            slideToCallLabel.textContent = 'In call';
            thumb.style.transform = `translateX(${maxSlide}px)`;
            currentX = maxSlide;
            launchZoomCall();
          }
        } else {
          resetThumb();
        }
      });

      window.api.onZoomMeetingClosed(() => {
        inCall = false;
        slideToCallLabel.textContent = 'Slide to call';
        resetThumb();
      });
    })();

    window.api.onZoomMeetingClosed(() => {
      stopRealtimeVoice();
      slideToCallLabel.textContent = 'Slide to call';
      if (endConversationRow) endConversationRow.style.display = 'none';
    });

    endConversationBtn.addEventListener('click', () => {
      stopRealtimeVoice();
      if (endConversationRow) endConversationRow.style.display = 'none';
    });
  </script>
</body>
</html>
