<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%;
      height: 100%;
      background: transparent;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      overflow: hidden;
    }

    .panel {
      position: absolute;
      top: 16px;
      right: 16px;
      bottom: 16px;
      width: 340px;
      background: rgba(20, 20, 30, 0.85);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

    /* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
    .header {
      padding: 16px 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      -webkit-app-region: drag;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .agent-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: all 0.3s ease;
    }

    .agent-icon.conceptual { background: rgba(139, 92, 246, 0.3); }
    .agent-icon.applied { background: rgba(59, 130, 246, 0.3); }
    .agent-icon.consolidation { background: rgba(16, 185, 129, 0.3); }
    .agent-icon.idle { background: rgba(255, 255, 255, 0.1); }

    .title {
      color: rgba(255, 255, 255, 0.9);
      font-size: 14px;
      font-weight: 600;
    }

    .subtitle {
      color: rgba(255, 255, 255, 0.4);
      font-size: 11px;
    }

    /* ‚îÄ‚îÄ Toggle button ‚îÄ‚îÄ */
    .toggle-btn {
      -webkit-app-region: no-drag;
      width: 40px;
      height: 24px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      position: relative;
      transition: background 0.3s;
      background: rgba(255, 255, 255, 0.15);
    }

    .toggle-btn.active {
      background: rgba(16, 185, 129, 0.6);
    }

    .toggle-btn::after {
      content: '';
      position: absolute;
      top: 3px;
      left: 3px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: white;
      transition: transform 0.3s;
    }

    .toggle-btn.active::after {
      transform: translateX(16px);
    }

    /* ‚îÄ‚îÄ Status bar ‚îÄ‚îÄ */
    .status-bar {
      padding: 8px 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }

    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.3);
      flex-shrink: 0;
      transition: background 0.3s;
    }

    .status-dot.ready { background: #fbbf24; }
    .status-dot.connecting { background: #f97316; animation: pulse 1s infinite; }
    .status-dot.active { background: #10b981; animation: pulse 2s infinite; }
    .status-dot.error { background: #ef4444; }
    .status-dot.disconnected { background: rgba(255, 255, 255, 0.3); }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    .status-text {
      color: rgba(255, 255, 255, 0.5);
      font-size: 11px;
      flex: 1;
    }

    .mic-indicator {
      font-size: 12px;
      opacity: 0.3;
      transition: opacity 0.3s;
    }

    .mic-indicator.listening {
      opacity: 1;
    }

    /* ‚îÄ‚îÄ Feed area ‚îÄ‚îÄ */
    .feed {
      flex: 1;
      overflow-y: auto;
      padding: 16px 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .feed::-webkit-scrollbar { width: 4px; }
    .feed::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 2px;
    }

    .feed-item {
      padding: 12px 14px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.06);
      animation: fadeIn 0.3s ease;
    }

    .feed-item .time {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.25);
      margin-bottom: 6px;
    }

    .feed-item .text {
      font-size: 13px;
      color: rgba(255, 255, 255, 0.8);
      line-height: 1.5;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .feed-item .speech-tag {
      font-size: 10px;
      color: rgba(139, 92, 246, 0.7);
      margin-bottom: 4px;
    }

    .feed-item.mode-CONCEPTUAL { border-left: 2px solid rgba(139, 92, 246, 0.5); }
    .feed-item.mode-APPLIED { border-left: 2px solid rgba(59, 130, 246, 0.5); }
    .feed-item.mode-CONSOLIDATION { border-left: 2px solid rgba(16, 185, 129, 0.5); }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: rgba(255, 255, 255, 0.25);
      font-size: 13px;
      text-align: center;
      padding: 40px;
      line-height: 1.6;
    }

    .empty-state .icon { font-size: 32px; margin-bottom: 12px; }

    /* ‚îÄ‚îÄ Visualization cards ‚îÄ‚îÄ */
    .viz-feed-card {
      margin-top: 4px;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.06);
    }
    .viz-feed-card .viz-title {
      font-size: 13px;
      color: rgba(255, 255, 255, 0.95);
      font-weight: 600;
      margin-bottom: 6px;
    }
    .viz-feed-card .viz-canvas {
      min-height: 80px;
      background: rgba(0, 0, 0, 0.15);
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 6px;
    }
    .viz-feed-card .viz-narration {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
      line-height: 1.4;
    }
    .viz-feed-card .katex { font-size: 1.05em; }
    .viz-feed-card video {
      width: 100%;
      border-radius: 8px;
    }

    /* ‚îÄ‚îÄ Avatar dropdown ‚îÄ‚îÄ */
    .avatar-row {
      -webkit-app-region: no-drag;
      padding: 10px 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .avatar-label {
      color: rgba(255, 255, 255, 0.6);
      font-size: 12px;
      font-weight: 500;
    }
    .avatar-select {
      flex: 1;
      max-width: 140px;
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(255, 255, 255, 0.08);
      color: rgba(255, 255, 255, 0.9);
      font-size: 13px;
      cursor: pointer;
    }
    .avatar-select:focus {
      outline: none;
      border-color: rgba(16, 185, 129, 0.5);
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</head>
<body>
  <div class="panel">
    <div class="avatar-row">
      <label for="avatarSelect" class="avatar-label">Avatar</label>
      <select id="avatarSelect" class="avatar-select" title="Choose avatar">
        <option value="plato">Plato</option>
        <option value="socrates">Einstein</option>
        <option value="einstein">Darwin</option>
      </select>
    </div>
    <div class="header">
      <div class="header-left">
        <div class="agent-icon idle" id="agentIcon">üëÅÔ∏è</div>
        <div>
          <div class="title" id="agentName">Learning Agent</div>
          <div class="subtitle" id="agentMode">Idle</div>
        </div>
      </div>
      <button class="toggle-btn" id="toggleBtn" title="Start/stop session"></button>
    </div>

    <div class="status-bar">
      <div class="status-dot" id="statusDot"></div>
      <span class="status-text" id="statusText">Initializing...</span>
      <span class="mic-indicator" id="micIndicator">üé§</span>
    </div>

    <div class="feed" id="feed">
      <div class="empty-state" id="emptyState">
        <div class="icon">üëÅÔ∏è</div>
        <div>Toggle the switch to start.<br>I'll watch your screen and listen<br>to understand what you're learning.</div>
      </div>
    </div>
  </div>

  <script>
    const feed = document.getElementById('feed');
    const emptyState = document.getElementById('emptyState');
    const toggleBtn = document.getElementById('toggleBtn');
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const micIndicator = document.getElementById('micIndicator');
    const agentIcon = document.getElementById('agentIcon');
    const agentName = document.getElementById('agentName');
    const agentMode = document.getElementById('agentMode');

    let isActive = false;

    // ‚îÄ‚îÄ Speech Recognition (Web Speech API ‚Äî runs locally) ‚îÄ‚îÄ
    let recognition = null;

    function startSpeechRecognition() {
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        console.warn('[Speech] Web Speech API not available');
        return;
      }

      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = false;
      recognition.lang = 'en-US';

      recognition.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; i++) {
          if (event.results[i].isFinal) {
            const transcript = event.results[i][0].transcript.trim();
            if (transcript) {
              console.log('[Speech]', transcript);
              window.api.sendSpeechTranscript(transcript);
            }
          }
        }
      };

      recognition.onerror = (event) => {
        console.warn('[Speech] Error:', event.error);
        // Restart on non-fatal errors
        if (event.error === 'no-speech' || event.error === 'aborted') {
          if (isActive) {
            setTimeout(() => {
              try { recognition.start(); } catch (e) {}
            }, 500);
          }
        }
      };

      recognition.onend = () => {
        // Auto-restart if session is still active
        if (isActive) {
          try { recognition.start(); } catch (e) {}
        }
        micIndicator.classList.toggle('listening', isActive);
      };

      try {
        recognition.start();
        micIndicator.classList.add('listening');
        console.log('[Speech] Recognition started');
      } catch (e) {
        console.error('[Speech] Start error:', e);
      }
    }

    function stopSpeechRecognition() {
      if (recognition) {
        try { recognition.stop(); } catch (e) {}
        recognition = null;
      }
      micIndicator.classList.remove('listening');
    }

    // ‚îÄ‚îÄ Avatar dropdown ‚îÄ‚îÄ
    document.getElementById('avatarSelect').addEventListener('change', (e) => {
      window.api.setAvatar(e.target.value);
    });

    // ‚îÄ‚îÄ IPC listeners ‚îÄ‚îÄ
    // ‚ö†Ô∏è TEMPORARY: Speech recognition disabled ‚Äî causes chunked_data_pipe spam in Electron
    // window.api.onStartMic(() => startSpeechRecognition());
    // window.api.onStopMic(() => stopSpeechRecognition());
    window.api.onStartMic(() => console.log('[Speech] Disabled for testing'));
    window.api.onStopMic(() => console.log('[Speech] Disabled for testing'));

    // ‚îÄ‚îÄ Visualization rendering ‚îÄ‚îÄ
    const BACKEND_ORIGIN = 'http://localhost:8080';

    function renderVizInCard(tier, payload, canvasEl) {
      if (!canvasEl) return;

      // LaTeX
      if (tier === 'latex' || (tier === 'static' && (payload.format || 'latex') === 'latex')) {
        var content = payload.content || '';
        if (window.katex) {
          canvasEl.innerHTML = '';
          var wrap = document.createElement('div');
          canvasEl.appendChild(wrap);
          try {
            katex.render(content, wrap, { throwOnError: false, displayMode: true });
          } catch (e) {
            wrap.innerHTML = '<pre style="color:#9ca3af;">' + escapeHtml(content) + '</pre>';
          }
        } else {
          canvasEl.innerHTML = '<pre style="color:#9ca3af;">' + escapeHtml(content) + '</pre>';
        }
        return;
      }

      // Mermaid (static with format=mermaid)
      if (tier === 'static' && payload.format === 'mermaid') {
        var content = payload.content || '';
        if (window.mermaid) {
          canvasEl.innerHTML = '<div class="mermaid">' + escapeHtml(content) + '</div>';
          mermaid.run({ nodes: [canvasEl.querySelector('.mermaid')] }).catch(function() {});
        } else {
          canvasEl.innerHTML = '<pre style="color:#9ca3af;">' + escapeHtml(content) + '</pre>';
        }
        return;
      }

      // D3 (unsandboxed iframe so it can load D3 from CDN)
      if (tier === 'd3' && payload.code) {
        var code = payload.code.replace(/<\/script/gi, '<\\/script');
        var html = '<!DOCTYPE html><html><head><meta charset="utf-8">'
          + '<script src="https://d3js.org/d3.v7.min.js"><\/script>'
          + '<style>body{margin:0;background:transparent;overflow:hidden;color:#e5e7eb;font-family:sans-serif;}'
          + 'svg text{fill:#e5e7eb;} svg line,svg path{stroke:#e5e7eb;}</style></head>'
          + '<body><div id="v" style="width:100%;height:100%;"></div>'
          + '<script>window.onerror=function(m){document.getElementById("v").innerHTML="<p style=color:#ef4444;font-size:12px>"+m+"</p>"};'
          + code
          + '; if(typeof draw==="function") draw(document.getElementById("v"));<\/script></body></html>';
        var iframe = document.createElement('iframe');
        iframe.style.cssText = 'width:100%;height:220px;border:0;border-radius:8px;background:rgba(0,0,0,0.15);';
        iframe.srcdoc = html;
        canvasEl.innerHTML = '';
        canvasEl.appendChild(iframe);
        return;
      }

      // Plotly
      if ((tier === 'plotly' || tier === 'interactive') && payload.plotly_figure && window.Plotly) {
        canvasEl.innerHTML = '';
        Plotly.newPlot(canvasEl, payload.plotly_figure.data || [], payload.plotly_figure.layout || {}, { responsive: true });
        return;
      }

      // Manim ‚Äî poll for rendered video
      if (tier === 'manim') {
        var statusUrl = payload.status_url;
        var narrationText = payload.narration || 'Rendering animation...';

        if (statusUrl) {
          canvasEl.innerHTML = '<p style="color:#9ca3af;text-align:center;">üé¨ ' + escapeHtml(narrationText) + '</p>' +
            '<p style="color:rgba(255,255,255,0.4);font-size:11px;text-align:center;">Rendering...</p>';
          var polls = 0, maxPolls = 80;
          var iv = setInterval(function() {
            polls++;
            fetch(BACKEND_ORIGIN + statusUrl).then(function(r) { return r.json(); }).then(function(data) {
              if (data.status === 'ready' && data.url) {
                clearInterval(iv);
                canvasEl.innerHTML = '<video src="' + BACKEND_ORIGIN + data.url + '" controls playsinline autoplay muted style="width:100%;border-radius:8px;"></video>';
              } else if (data.status === 'error') {
                clearInterval(iv);
                canvasEl.innerHTML = '<p style="color:#ef4444;text-align:center;font-size:12px;">' + escapeHtml(data.error || 'Render failed') + '</p>';
              }
            }).catch(function() {});
            if (polls >= maxPolls) {
              clearInterval(iv);
              canvasEl.innerHTML = '<p style="color:#9ca3af;text-align:center;">Render timed out.</p>';
            }
          }, 2000);
        } else {
          canvasEl.innerHTML = '<p style="color:#9ca3af;text-align:center;">üé¨ ' + escapeHtml(narrationText) + '</p>';
        }
        return;
      }

      // Fallback
      canvasEl.innerHTML = '<p style="color:#6b7280;">' + escapeHtml(payload.title || 'Visualization') + '</p>';
    }

    // ‚îÄ‚îÄ Agent responses from backend (via WebSocket ‚Üí main ‚Üí IPC) ‚îÄ‚îÄ
    window.api.onAgentResponse((msg) => {
      emptyState.style.display = 'none';

      const meta = msg.metadata || {};
      const tier = meta.tier;
      const vizPayload = meta.visualization || meta.scene || {};
      const isViz = msg.content_type === 'visualization' || (msg.tool_used === 'visualization' && (tier || vizPayload.tier));

      if (isViz && (tier || vizPayload.tier)) {
        const actualTier = tier || vizPayload.tier;
        const cardId = 'viz-' + Date.now();
        const item = document.createElement('div');
        item.className = 'feed-item viz-feed-card';
        const now = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        item.innerHTML = '<div class="time">' + now + ' üé® ' + actualTier + '</div>' +
          '<div class="viz-title">' + escapeHtml(vizPayload.title || 'Visualization') + '</div>' +
          '<div class="viz-canvas" id="' + cardId + '"></div>' +
          '<div class="viz-narration">' + escapeHtml(msg.content || vizPayload.narration || '') + '</div>';
        feed.appendChild(item);
        feed.scrollTop = feed.scrollHeight;
        const canvas = document.getElementById(cardId);
        if (canvas) setTimeout(function() { renderVizInCard(actualTier, vizPayload, canvas); }, 50);
        return;
      }

      // Non-visualization agent response
      const agentLabel = { conceptual: 'Conceptual', applied: 'Applied', extension: 'Extension', visualizer: 'Visualizer' }[msg.agent_type] || msg.agent_type || 'Agent';
      const item = document.createElement('div');
      item.className = 'feed-item';
      const now = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      item.innerHTML = '<div class="time">' + now + ' ü§ñ ' + escapeHtml(agentLabel) + '</div>' +
        '<div class="text">' + escapeHtml(msg.content || '') + '</div>';
      feed.appendChild(item);
      feed.scrollTop = feed.scrollHeight;
    });

    window.api.onGeminiResponse((data) => {
      emptyState.style.display = 'none';

      // Detect mode from response
      let mode = '';
      const text = data.text;
      if (text.includes('"CONCEPTUAL"') || text.includes("CONCEPTUAL")) mode = 'CONCEPTUAL';
      else if (text.includes('"APPLIED"') || text.includes("APPLIED")) mode = 'APPLIED';
      else if (text.includes('"CONSOLIDATION"') || text.includes("CONSOLIDATION")) mode = 'CONSOLIDATION';

      if (mode) updateAgentDisplay(mode);

      const item = document.createElement('div');
      item.className = `feed-item ${mode ? 'mode-' + mode : ''}`;

      const time = new Date(data.timestamp);
      const timeStr = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });

      // Try to parse and display nicely
      let displayText = text;
      try {
        // Extract JSON from response (might have markdown fences)
        const jsonMatch = text.match(/\{[\s\S]*?\}/);
        if (jsonMatch) {
          const parsed = JSON.parse(jsonMatch[0]);
          displayText = `üìã ${parsed.activity || 'unknown'}\nüìö ${parsed.topic || 'unknown'}\nüß† ${parsed.mode || 'unknown'}`;
          if (parsed.stuck) displayText += '\n‚ö†Ô∏è Might be stuck';
          if (parsed.notes) displayText += `\nüí¨ ${parsed.notes}`;
        }
      } catch (e) {
        // Not JSON, show raw text
      }

      item.innerHTML = `
        <div class="time">${timeStr}</div>
        <div class="text">${escapeHtml(displayText)}</div>
      `;

      feed.appendChild(item);

      // Keep max 30 items
      const items = feed.querySelectorAll('.feed-item');
      while (items.length > 30 && feed.children.length > 31) {
        feed.removeChild(feed.children[1]);
      }

      feed.scrollTop = feed.scrollHeight;
    });

    window.api.onStatusUpdate((data) => {
      statusDot.className = `status-dot ${data.status}`;
      statusText.textContent = data.message;
    });

    // ‚îÄ‚îÄ Toggle ‚îÄ‚îÄ
    toggleBtn.addEventListener('click', () => {
      isActive = !isActive;
      toggleBtn.classList.toggle('active', isActive);
      window.api.toggleSession();

      if (!isActive) {
        agentIcon.className = 'agent-icon idle';
        agentIcon.textContent = 'üëÅÔ∏è';
        agentName.textContent = 'Learning Agent';
        agentMode.textContent = 'Idle';
      }
    });

    // ‚îÄ‚îÄ Agent display ‚îÄ‚îÄ
    function updateAgentDisplay(mode) {
      const agents = {
        CONCEPTUAL: { icon: 'üßê', name: 'Sage', color: 'conceptual' },
        APPLIED: { icon: 'üîß', name: 'Builder', color: 'applied' },
        CONSOLIDATION: { icon: 'üîÑ', name: 'Echo', color: 'consolidation' },
      };
      const agent = agents[mode];
      if (!agent) return;

      agentIcon.textContent = agent.icon;
      agentIcon.className = `agent-icon ${agent.color}`;
      agentName.textContent = agent.name;
      agentMode.textContent = mode.charAt(0) + mode.slice(1).toLowerCase();
    }

    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }
  </script>
</body>
</html>
